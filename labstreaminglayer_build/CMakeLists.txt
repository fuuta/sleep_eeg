cmake_minimum_required(VERSION 3.5)
project(LabStreamingLayer)

if(NOT CMAKE_BUILD_TYPE)
	set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Build type" FORCE)
endif()
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
	SET(CMAKE_INSTALL_PREFIX "${CMAKE_CURRENT_LIST_DIR}/build/install/lsl_${CMAKE_BUILD_TYPE}" CACHE PATH
		"Where to put redistributable binaries" FORCE)
	message(WARNING "CMAKE_INSTALL_PREFIX default initialized to ${CMAKE_INSTALL_PREFIX}")
endif()

# add the liblsl build directory
add_subdirectory(LSL/liblsl)


# When building the whole tree, we define LSL_INSTALL_ROOT as the current directory.
# In this case we have liblsl as an actual target, so we don't need to find it.
# In all other cases, LSL_INSTALL_ROOT must be set to an actual **installed** lsl root.
set(LSL_INSTALL_ROOT ${CMAKE_CURRENT_LIST_DIR} CACHE STRING
	"LSL root directory, LSL_INSTALL_ROOT/cmake contains modules to set everything up / find liblsl" FORCE)

# When using a precompiled lsl, liblsl is installed as an exported target with
# an autogenerated FindLSL.cmake in LSL_INSTALL_ROOT/cmake so the apps and
# LSLAppBoilerplate don't care where LSL_INSTALL_ROOT was defined

# load settings for all LSL Apps
list(APPEND CMAKE_MODULE_PATH "${LSL_INSTALL_ROOT}/cmake/")
include(LSLAppBoilerplate)

# include the Apps directory which defines options, which Apps will be built
# and includes their build configurations
add_subdirectory(Apps)

install(FILES
	cmake/LSLAppBoilerplate.cmake
	DESTINATION LSL/cmake)

# add a target that zips up a built installation tree
# Example: cmake --build path/to/build_dir --target LSLPACKAGE
set(LSLPACKAGENAME "LSL_${CMAKE_SYSTEM_NAME}.7z")
add_custom_target(LSLPACKAGE 
	COMMAND ${CMAKE_COMMAND} "--build" "${CMAKE_BINARY_DIR}" "--target" "install"
	COMMAND ${CMAKE_COMMAND} "-E" "tar" "cvf" "${LSLPACKAGENAME}" "--format=7zip" "${CMAKE_INSTALL_PREFIX}"
	BYPRODUCTS ${LSLPACKAGENAME}
	WORKING_DIRECTORY "${CMAKE_INSTALL_PREFIX}/../")
